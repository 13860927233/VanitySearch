#include "GPUEngine.h"

using namespace std;

static string space(int n) {

  string ret;
  for(int i=0;i<n;i++)
    ret.append("  ");
  return ret;

}

void  GPUEngine::ComputeIndex(vector<int> &s, int depth, int n) {

  int log2n = (int)(log2(n) + 0.5);

  s.push_back(1);
  s.push_back(0);

  for (int i = 1; i < depth; i++) {
    int sSize = (int)s.size();
    for (int j = 0; j < sSize; j++) {
      s.push_back(s[j] + (1 << i));
    }
  }

  // Add offset
  if (s.size() != n) {
    int sSize = (int)s.size();
    vector<int> ns;
    int offset = 0;
    int add = n;
    for (int i = depth; i < log2n; i++) {
      offset += add;
      add = add / 2;
    }
    for (int i = 0; i < sSize; i++) {
      ns.push_back(s[i] + offset);
    }
    s = ns;
  }


}

void GPUEngine::Browse(FILE *f, int depth, int max, int s) {

  if (depth == 2) {

    fprintf(f, "%sfor (int i%d = 0; i%d < 4; i%d++) {\n",
      space(depth-1).c_str(),depth,depth,depth);
    fprintf(f, "%suint64_t t%d[4];\n", 
      space(depth).c_str(),depth);
    fprintf(f, "%sint off%d=2*i%d;\n",
      space(depth).c_str(), depth,depth);

    fprintf(f, "%s_MontgomeryMult(t%d,subp[GR_IDX[i%d/2]],subp[GR_IDX[i%d+%d]]);\n",
      space(depth).c_str(),depth, depth, depth, s);

    Browse(f, depth + 1, max, s + (1 << depth));

    fprintf(f, "%s}\n", space(depth - 1).c_str());

  } else if (depth == max - 1) {

    fprintf(f, "%sfor (int i%d = 0; i%d < 2; i%d++) {\n",
      space(depth - 1).c_str(), depth, depth, depth);
    fprintf(f, "%s_MontgomeryMult(r[i%d+off%d],t%d,subp[GR_IDX[i%d+off%d+%d]]);\n",
      space(depth).c_str(),depth,depth-1,depth - 1,depth,depth-1,s);
    fprintf(f, "%s}\n", space(depth - 1).c_str());

  } else {

    fprintf(f, "%sfor (int i%d = 0; i%d < 2; i%d++) {\n",
      space(depth - 1).c_str(), depth, depth, depth);
    fprintf(f, "%suint64_t t%d[4];\n",
      space(depth).c_str(), depth);
    fprintf(f, "%sint off%d=2*(off%d + i%d);\n",
      space(depth).c_str(), depth, depth-1, depth);

    fprintf(f, "%s_MontgomeryMult(t%d,t%d,subp[GR_IDX[i%d+off%d+%d]]);\n",
      space(depth).c_str(), depth, depth - 1,  depth, depth - 1, s);

    Browse(f, depth + 1, max, s + (1 << depth));

    fprintf(f, "%s}\n", space(depth - 1).c_str());

  }

}

void GPUEngine::GenerateCode(Secp256K1 &secp, int size) {

  // Compute generator table
  Point *Gn = new Point[size];
  Point g = secp.G;
  Gn[0] = g;
  g = secp.DoubleDirect(g);
  Gn[1] = g;
  for (int i = 2; i < size; i++) {
    g = secp.AddDirect(g, secp.G);
    Gn[i] = g;
  }

  int log2n = (int)(log2(size) + 0.5);

  // Write file
  FILE *f = fopen("GPUGroup.h", "w");

  fprintf(f, "// File generated by GPUEngine::GenerateCode()\n");
  fprintf(f, "// GROUP definitions\n");
  fprintf(f, "#define GRP_SIZE %d\n", size);
  fprintf(f, "#define GRP_SIZE_LOG2 %d\n\n", log2n);
  fprintf(f, "// SecpK1 Generator table (Contains G,2G,3G,...)\n");
  fprintf(f, "__device__ __constant__ uint64_t Gx[][4] = {\n");
  for (int i = 0; i < size; i++) {
    fprintf(f, "  %s,\n", Gn[i].x.GetC64Str(4).c_str());
  }
  fprintf(f, "};\n");

  fprintf(f, "__device__ __constant__ uint64_t Gy[][4] = {\n");
  for (int i = 0; i < size; i++) {
    fprintf(f, "  %s,\n", Gn[i].y.GetC64Str(4).c_str());
  }
  fprintf(f, "};\n\n");

  // Compute indexes
  fprintf(f, "__device__ __constant__ int GR_IDX[] = {\n  ");
  for (int i = 1; i <= log2n; i++) {
    vector<int> s;
    ComputeIndex(s, i, size);
    for (int j = 0; j < s.size(); j++) {
      fprintf(f, "%2d,", s[j]);
    }
    fprintf(f, "\n  ");
  }
  fprintf(f, "\n};\n");

  fprintf(f, "\n");
  fprintf(f, "// Compute all ModInv of the group\n");
  fprintf(f, "__device__ void _ModInvGrouped(uint64_t r[GRP_SIZE][4]) {\n\n");
  fprintf(f, "  uint64_t subp[(2 * GRP_SIZE - 1)][4];\n");
  fprintf(f, "\n");
  fprintf(f, "  // Compute sub product tree (n modular mult)\n");
  fprintf(f, "  memcpy(subp[0],r[0], 32 * GRP_SIZE);\n");
  fprintf(f, "  uint32_t off = 0;\n");
  fprintf(f, "  uint32_t idx = GRP_SIZE;\n");
  fprintf(f, "  uint32_t s = GRP_SIZE / 2;\n");
  fprintf(f, "  for (uint32_t j = 0; j < GRP_SIZE_LOG2; j++) {\n");
  fprintf(f, "    for (uint32_t i = 0; i < s; i++) {\n");
  fprintf(f, "      _MontgomeryMult(subp[idx++],subp[2 * i + off],subp[2 * i + 1 + off]);\n");
  fprintf(f, "    }\n");
  fprintf(f, "    off += 2 * s;\n");
  fprintf(f, "    s = s / 2;\n");
  fprintf(f, "  }\n");
  fprintf(f, "\n");
  fprintf(f, "  // The last index contains the complete prodcut\n");
  fprintf(f, "  // We need 320bit signed int for ModInv\n");
  fprintf(f, "  uint64_t P[NBBLOCK];\n");
  fprintf(f, "  Load256(P, subp[idx - 1]);\n");
  fprintf(f, "  P[4] = 0;\n");
  fprintf(f, "  _ModInv(P);\n");
  fprintf(f, "\n");
  fprintf(f, "  // Multiply the 2 starting roots by the inverse\n");
  fprintf(f, "  _MontgomeryMult(subp[idx - 2], P);\n");
  fprintf(f, "  _MontgomeryMult(subp[idx - 3], P);\n");
  fprintf(f, "\n");
  fprintf(f, "  // Browse tree (2*n modular mult)\n");

  // Generate iterative tree browsing
  Browse(f, 2, log2n + 1, 2);

  fprintf(f, "\n");
  fprintf(f, "}\n");

  fclose(f);
  delete[] Gn;

}
